{
  "hash": "871ad8698f11f84493eaa073b284930f",
  "result": {
    "markdown": "---\ntitle: \"Contando letras\"\ndescription: \"Resolvemos un reto de l√≥gica de programaci√≥n, aprovechamos de hacerlos de varias formas y nos lanzamos con unos test unitarios adem√°s!\"\nauthor: \"Paulo Villarroel\"\ndate: \"2022-11-23\"\ncategories: [r, python, tutorial, katas]\nimage: \"letters.jpg\"\n---\n\n\nHola!!\n\nQue bueno que est√©s por estos lados nuevamente! Porque ya has le√≠do mis otros art√≠culos, verdad??\n\nVerdad!!??\n\nOjito...\n\njajajaja ü§£\n\nYa, ok... En serio. Lo que vamos a ver en este art√≠culo es algo interesante. O es lo que pienso. Lo que har√© es resolver un reto de l√≥gica de programaci√≥n (o *kata* le dicen algunos). Pero quiero darle una peque√±a vuelta de tuerca al tema. No quiero que solo sea poner el c√≥digo y punto. Sino que explicar√© varias formas de resolverlo, algunas m√°s verbosas (es decir, con m√°s l√≠neas de c√≥digo) para que sea m√°s simple de seguir la l√≥gica y el paso a paso. La idea es evitar la \"magia\" o c√≥digos que hacen todo por debajo y uno ni se entera. Los explicar√© de forma progresiva. Tambi√©n usar√© otras formas de resolverlo con menos c√≥digo. Mi intenci√≥n es que veas que, generalmente, hay varias formas de resolver las cosas en programaci√≥n. No hay mejores o peores perse, pero hay algunos que son m√°s eficientes que otros o que son mas legibles y comprensibles.\n\nPara resolverlo usar√©, principalmente, el lenguaje de progamaci√≥n R y tambi√©n pondr√© algo en Python por ah√≠. Me interesa que entiendas la l√≥gica de la soluci√≥n, el lenguaje que uses es lo de menos.\n\nPor esos mismos motivos (para la l√≥gica), es que evitar√© usar librer√≠as o dependencias externas a las del propio lenguaje y que tienden a estar presentes en muchos lenguajes, quiz√°s con una sintaxis (la forma en c√≥mo se escribe) algo distinta, pero que hacen lo mismo. Y como te mencion√©, no busco generar el c√≥digo m√°s corto, eficiente o lindo, sino que sea f√°cil de entender.\n\nEstamos?\n\n# El problema\n\nEl problema no es nuevo ni una creaci√≥n m√≠a, sino que es de una web cl√°sica en donde puedes encontrar muchos desaf√≠os o retos de c√≥digo, llamada [CodeWars](https://www.codewars.com/).\n\nEl desaf√≠o que veremos ahora dice as√≠:\n\n[![](kata-vowels.jpg){fig-align=\"center\" width=\"800\"}](https://www.codewars.com/kata/54ff3102c1bad923760001f3/r)\n\nB√°sicamente, la idea es crear una funci√≥n que permita contar las vocales que tiene un determinado texto.\n\nSe entiende?\n\nEs simple. A priori, al menos.\n\n# Soluciones\n\nYa. Tenemos nuestro desaf√≠o, ahora veamos c√≥mo podemos resolverlo.\n\nMi primer approach ser√° con R. Crear√© una funci√≥n que cuente las vocales de un texto que le pasemos a esa funci√≥n. Recuerda que para crear o definir una funci√≥n se usa `function`. A ella le agregamos un par√°metro `text`, que ser√° el texto que queremos analizar y contar las vocales.\n\nAntes de partir, vamos a definir unos test unitarios. Los test unitarios son pruebas que consisten en aislar una parte del c√≥digo y comprobar que funciona a lo esperado. Son peque√±os tests que validan el comportamiento de un objeto y la l√≥gica, fundamentalmente. En R, para realizar este tipo de test usaremos la librer√≠a `testthat`. Se escapa de los alcances de este art√≠culo, pero te recomiendo que aprendas a realizar *testing*, pues es una forma de asegurarte que las cosas salen como deber√≠an salir, lo cual es especialmente √∫til cuando tienes desarrollos un poco m√°s extensos, hay varias personas metiendo mano o haces cambios en el c√≥digo y no quieres roper nada (roper es un t√©rmino usado en programaci√≥n para aludir a que ya no funciona bien algo). Si corremos el c√≥digo que te dejo abajo ver√°s que arroja puros errores!!!!! No!!!!!!!\n\nBueno, qu√© esperas? Si no hemos definido ninguna funci√≥n ni nada jajajaj ü§™\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(testthat) # librer√≠a para test unitarios en R\n```\n:::\n\n::: {.cell}\n\n```{.yaml .cell-code}\ntest_count_vowels <- test_that(\"Example Tests\", {\n  expect_equal(count_vowels(\"Esta es otra frase\"), \"Number of vowels: 7\")\n  expect_equal(count_vowels(\"Ma√±ana salimos al parque\"), \"Number of vowels: 10\")\n  expect_equal(count_vowels(\"\"), \"Number of vowels: 0\")\n})\n\n# ‚îÄ‚îÄ Error (Line 2): Example Tests ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# Error in `count_vowels(\"Esta es otra frase\")`: could not find function \"count_vowels\"\n# Backtrace:\n#  1. testthat::expect_equal(count_vowels(\"Esta es otra frase\"), \"Number of vowels: 7\")\n#  2. testthat::quasi_label(enquo(object), label, arg = \"object\")\n#  3. rlang::eval_bare(expr, quo_get_env(quo))\n```\n:::\n\n\nOk. Ya tenemos nuetro test que falla por todos lados. Ahora debemos arreglarlo.\n\nPartiremos definiendo nuestra funci√≥n `count_vowels`, que como te mencion√© antes, le pasaremos como argumento un texto en el par√°metro `text`.\n\nA ver... mi l√≥gica de pensamiento es la siguiente... como necesito contar las vocales que tiene un texto, primero le tengo que decir al computador cu√°les son las letras que deseo contar (las vocales). Una vez que tenga eso claro, voy a buscar esas vocales en el texto, contar cu√°ntas hay y sumarlas.\n\nTener en mente la l√≥gica es lo b√°sico. Antes de ponder a escribir c√≥digo. Primero dise√±a la soluci√≥n (o algo parecido) en tu mente. Muchas veces yo uso un l√°piz y papel para tirar dibujos que me permitan entender los pasos y partes.\n\nVamos con el c√≥digo. Dentro de la funci√≥n especificamos:\n\n-   Creamos el objeto `vowels` que es un vector de *strings* con las vocales.\n\n-   Para poder buscar las vocales en el texto, necesito separar el texto en todas sus letras, porque mi b√∫squeda y conteo es por letra, no por un conjunto de ellas.\n\n-   Creamos el objeto `split_text` que ser√° un vector con todas las letras del texto ya separadas. Para evitar complicaciones, pondremos todo a min√∫sculas. Recuerda que C no es igual a c, por ejemplo. Este tema no lo hab√≠a considerado al inicio, pero me di cuenta que no sumaba bien con algunas palabras y era por el asunto de las may√∫sculas.\n\n-   Como deseo contar las vocales dentro del texto (ya separado por letras), usar√© un *for* para ello. Dejar√© un objeto `char_count = 0` en donde ir√© acumulando las sumas de vocales.\n\n-   Implemento el *for*. F√≠jate que en la medida que recorro el vector del texto separado y encuentro una vocal, sumo 1 y lo voy acumulando. Para realizar esab b√∫squeda, us√© `char %in% vowels`.\n\n-   Te recomiendo que veas la documentaci√≥n del operador `%in%` para m√°s detalles, pero lo que hace es lo que te mencion√©, recorre un vector por cada uno de sus elementos.\n\n-   Finalmente, imprimo por consola ese n√∫mero acumulado de letras. Le puse un mensaje para que sea m√°s entendible la salida del c√≥digo.\n\nAs√≠ quedar√≠a esa implementaci√≥n:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_vowels <- function(text) {\n  vowels <- c(\"a\", \"e\", \"i\", \"o\", \"u\")\n  split_text <- tolower(unlist(strsplit(text, \"\")))\n  char_count <- 0\n\n  for (char in split_text) {\n    if (char %in% vowels) {\n      char_count <- char_count + 1\n    }\n  }\n  print(paste0(\"Number of vowels: \", char_count))\n}\n```\n:::\n\n\nPodemos probarla con algunos ejemplos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_vowels(\"hllp\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Number of vowels: 0\"\n```\n:::\n\n```{.r .cell-code}\ncount_vowels(\"paulo\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Number of vowels: 3\"\n```\n:::\n\n```{.r .cell-code}\ncount_vowels(\"Ma√±ana salimos al parque\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Number of vowels: 10\"\n```\n:::\n:::\n\n\nOk... al parecer funciona... Veamos c√≥mo le va a nuestra funci√≥n con el test unitario:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_count_vowels <- test_that(\"Example Tests\", {\n  expect_equal(count_vowels(\"Esta es otra frase\"), \"Number of vowels: 7\")\n  expect_equal(count_vowels(\"Ma√±ana salimos al parque\"), \"Number of vowels: 10\")\n  expect_equal(count_vowels(\"\"), \"Number of vowels: 0\")\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Number of vowels: 7\"\n[1] \"Number of vowels: 10\"\n[1] \"Number of vowels: 0\"\nTest passed üéâ\n```\n:::\n:::\n\n\nGenial!!!!\n\nPasamos!!!! üéâ\n\nVeamos una implementaci√≥n similar, pero esta vez en Python:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef getCount(text):\n    text = text.lower()\n    vowels = ['a','e','i','o','u']\n    numVowels = 0\n    \n    for char in text:\n        if (char in vowels):\n            numVowels += 1\n    \n    print(f\"Number of vowels: {numVowels}\")\n```\n:::\n\n\nRevisemos unos ejemplos:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ngetCount(\"paulo\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of vowels: 3\n```\n:::\n\n```{.python .cell-code}\ngetCount(\"Ma√±ana salimos al parque\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of vowels: 10\n```\n:::\n:::\n\n\nOk... tenemos nuestras primeras formas de resolver este desaf√≠o de c√≥digo.\n\nHagamos una peque√±a variaci√≥n al desaf√≠o. Anteriomente est√°bamos contando todas las vocales que ten√≠a un texto. ¬øPero qu√© pasa si ahora lo que queremos saber es cu√°l es la vocal que m√°s repite?\n\nHagamos nuestros test primero, que como ya sabes, van a fallar porque no tenemos nada a√∫n.\n\n\n::: {.cell}\n\n```{.yaml .cell-code}\ntest_count_vowels <- test_that(\"Example Tests\", {\n  expect_equal(max_vowels(\"Esto es un texto\"), \"Vowel: e / Freq: 3\")\n  expect_equal(max_vowels(\"Hoy hizo calor\"), \"Vowel: o / Freq: 3\")\n  expect_equal(max_vowels(\"\"), \"No vowels in text\")\n})\n\n# ‚îÄ‚îÄ Error (Line 2): Example Tests ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# Error in `max_vowels(\"Esto es un texto\")`: could not find function \"max_vowels\"\n# Backtrace:\n#  1. testthat::expect_equal(max_vowels(\"Esto es un texto\"), \"Vowel: e / Freq: 3\")\n#  2. testthat::quasi_label(enquo(object), label, arg = \"object\")\n#  3. rlang::eval_bare(expr, quo_get_env(quo))\n```\n:::\n\n\nVamos a usar parte de lo que tenemos realizado ya, y su l√≥gica por cierto. Finalmente, igual necesitamos identificar las vocales que hay en el texto, pero en esta ocasi√≥n, en vez de sumarlas, lo que haremos es contar cada vocal cu√°ntas apariciones tiene y seleccionaremos la que tiene mayor frecuencia.\n\nLa diferencia m√°s relevante con el reto anterior es que ahora debemos contar individualmente cada vocal. Antes solo acumul√°bamos la suma de las aparaciones. Para eso, me parece que m√°s l√≥gico armar una tabla con las vocales que tiene el texto y la frecuencia de cada una.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntext <- \"Esta es una prueba del texto\"\n\nvowels <- c(\"a\", \"e\", \"i\", \"o\", \"u\")\nsplit_text <- tolower(unlist(strsplit(text, \"\")))\ntable_freq <- data.frame(table(split_text[split_text %in% vowels]))\n```\n:::\n\n\nEl objeto `table_freq` contiene la tabla que te mencionaba. F√≠jate que lo que hice fue transformar una tabla media rara a un dataframe, que es m√°s √∫til para trabajar y calcular el m√°ximo de frecuencias.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(split_text[split_text %in% vowels])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\na e o u \n3 5 1 2 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(table(split_text[split_text %in% vowels]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Var1 Freq\n1    a    3\n2    e    5\n3    o    1\n4    u    2\n```\n:::\n:::\n\n\nCon esa tabla ya hecha, lo que debemos hacer es buscar la frecuencia m√°s alta (`max`) e indicar la vocal que corresponde a ese valor. Para eso, analiza esta l√≠nea de c√≥digo `table_freq$Var1[table_freq$Freq == max]`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax_vowels <- function(text) {\n  vowels <- c(\"a\", \"e\", \"i\", \"o\", \"u\")\n  split_text <- tolower(unlist(strsplit(text, \"\")))\n  table_freq <- data.frame(table(split_text[split_text %in% vowels]))\n  max <- max(table_freq$Freq)\n  max_vowels_text <- table_freq$Var1[table_freq$Freq == max]\n\n  print(paste0(\"Vowel: \", max_vowels_text, \" / Freq: \", max))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmax_vowels(\"La salud necesita mejores personas\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Vowel: e / Freq: 5\"\n```\n:::\n:::\n\n\nVolvamos a probar nuestros test...\n\n\n::: {.cell}\n\n```{.yaml .cell-code}\ntest_count_vowels <- test_that(\"Example Tests\", {\n  expect_equal(max_vowels(\"Esto es un texto\"), \"Vowel: e / Freq: 3\")\n  expect_equal(max_vowels(\"Hoy hizo calor\"), \"Vowel: o / Freq: 3\")\n  expect_equal(max_vowels(\"\"), \"No vowels in text\")\n})\n\n# [1] \"Vowel: e / Freq: 3\"\n# [1] \"Vowel: o / Freq: 3\"\n# [1] \"Vowel:  / Freq: -Inf\"\n# ‚îÄ‚îÄ Failure (Line 2): Example Tests ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# max_vowels(\"Esto es un texto\") not equal to \"Vowel: 3 / Freq: 3\".\n# 1/1 mismatches\n# x[1]: \"Vowel: e / Freq: 3\"\n# y[1]: \"Vowel: 3 / Freq: 3\"\n# \n# ‚îÄ‚îÄ Warning (Line 4): Example Tests ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# no non-missing arguments to max; returning -Inf\n# Backtrace:\n#  1. testthat::expect_equal(max_vowels(\"\"), \"No vowels in text\")\n#  4. global max_vowels(\"\")\n# \n# ‚îÄ‚îÄ Failure (Line 4): Example Tests ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# max_vowels(\"\") not equal to \"No vowels in text\".\n# 1/1 mismatches\n# x[1]: \"Vowel:  / Freq: -Inf\"\n# y[1]: \"No vowels in text\"\n```\n:::\n\n\nMmmmmmm. A ver. Los 2 primeros test pasaron, pero el tercero fall√≥, el que tiene un argumento vac√≠o.\n\nEn el ejemplo anterior, cuando le pasamos un argumento vacio no arroj√≥ error, pero ac√° si. Posiblemente el tema pasa por la tabla.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntext <- \"\"\n\nvowels <- c(\"a\", \"e\", \"i\", \"o\", \"u\")\nsplit_text <- tolower(unlist(strsplit(text, \"\")))\ntable_freq <- data.frame(table(split_text[split_text %in% vowels]))\n\ntable_freq\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Freq\n<0 rows> (or 0-length row.names)\n```\n:::\n:::\n\n\nSi le pasamos un texto vac√≠o, no se genera la tabla, nos da como resultado `0 rows`. Bueno, es l√≥gico. Si no hay nada, la tabla no existe b√°sicamente. Para resolver este problema, podr√≠amos agregar un condicional a la funci√≥n. Lo que deber√≠a pasar es que cuando se detecte que el texto es vac√≠o, nos de un mensaje de error o algo similar, y si no es as√≠, que haga el tema de la tabla y todo lo dem√°s.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax_vowels <- function(text) {\n  vowels <- c(\"a\", \"e\", \"i\", \"o\", \"u\")\n  split_text <- tolower(unlist(strsplit(text, \"\")))\n\n  if (text == \"\") {\n    \n    print(\"No vowels in text\")\n    \n  } else {\n    \n    table_freq <- data.frame(table(split_text[split_text %in% vowels]))\n    max <- max(table_freq$Freq)\n    max_vowels_text <- table_freq$Var1[table_freq$Freq == max]\n\n    print(paste0(\"Vowel: \", max_vowels_text, \" / Freq: \", max))\n    \n  }\n}\n```\n:::\n\n\nCorramos nuevamente nuestros lindos test unitarios:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_count_vowels <- test_that(\"Example Tests\", {\n  expect_equal(max_vowels(\"Esto es un texto\"), \"Vowel: e / Freq: 3\")\n  expect_equal(max_vowels(\"Hoy hizo calor\"), \"Vowel: o / Freq: 3\")\n  expect_equal(max_vowels(\"\"), \"No vowels in text\")\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Vowel: e / Freq: 3\"\n[1] \"Vowel: o / Freq: 3\"\n[1] \"No vowels in text\"\nTest passed ü•≥\n```\n:::\n:::\n\n\nYuju!!!! üòç\n\nTe dejo tarea para la casa. Mira el resultado siguiente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax_vowels(\"eeeoooaqui\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Vowel: e / Freq: 3\" \"Vowel: o / Freq: 3\"\n```\n:::\n:::\n\n\nEpa! Ac√° las vocales e y o tienen ambas una frecuencia de 3 y son las m√°s altas. Nuestro c√≥digo no resuelve bien eso. Muestra correctamente las vocales, pero el mensaje es extra√±o. Se podr√≠a hacer mejor.\n\nEs tu turno!! Int√©ntalo.\n\nAhora te voy a mostrar unas cuantas soluciones, pero con menos c√≥digo. Es m√°s complejo de entender si no sabes bien lo que hace cada funci√≥n, pero me parece interesante mostrarte otras opciones de resolver el problema original (el de contar vocales).\n\n**Opci√≥n 1:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_count_vowels <- function(text){\n  vowels <- nchar(gsub(\"[^aeiou]\", \"\", text, ignore.case = TRUE))\n  print(paste0(\"Number of vowels: \", vowels))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nget_count_vowels(\"Esta es otra frase\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Number of vowels: 7\"\n```\n:::\n:::\n\n\n**Opci√≥n 2:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr) # Usando esta librer√≠a\n\ncount_vowels_lib <- function(text){\n  str_count(text, \"[AEIOUaeiou]\")\n  }\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_vowels_lib(\"Esta es una prueba de texto\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11\n```\n:::\n:::\n\n\n**Opci√≥n 3:**\n\n\n::: {.cell}\n\n```{.python .cell-code}\ngetCount = lambda s: sum(s.count(i) for i in 'aeiou') # Opci√≥n un poco cr√≠ptica\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ngetCount(\"Frase linda\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n```\n:::\n:::\n\n\n# Finalmente\n\nUf! Teminamos este art√≠culo. Espero que te haya gustado y, principalmente, haya sido de utilidad.\n\nEspero haber sido claro en la l√≥gica de pensamiento y la forma de resolver un problema. Adem√°s, de mostrarte muchas formas de abordarlo en distintos idiomas. Y algo que quiz√°s pas√≥ medio desapercibido, pero es muy relevante, son los [test unitarios](https://testthat.r-lib.org/) y la arquitectura de desarrollo TDD (T*est Driven Development)*. Esto ayuda mucho a tener un c√≥digo sostenible y si le haces cambios y falla, te vas a dar cuenta.\n\nRecuerda dejar tus comentarios e inscribirte en el blog (en la secci√≥n de m√°s abajo).\n\nNos vemos!! ü§ó\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}