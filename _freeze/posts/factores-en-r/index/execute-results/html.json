{
  "hash": "b51e95893063df821a5ec8e8d7aa2654",
  "result": {
    "markdown": "---\ntitle: \"Factores en R\"\ndescription: \"Breve tutorial sobre las funciones m√°s interesantes para trabajar con factores en R.\"\nauthor: \"Paulo Villarroel\"\ndate: \"2022-10-04\"\ncategories: [r, tutorial]\nimage: \"legos.jpg\"\n---\n\n\nHola!!\n\nHoy toca ver c√≥digo. Yeahhh!!! üòÅ\n\nEn mi experiencia, uno de los aspectos m√°s relvantes a la hora de trabajar con datos, es saber manejar los datos categ√≥ricos o factores.\n\nEn la vida nos topamos a cada instante con este tipo de datos. Cuando vamos al supermercado, compramos frutas, l√°cteos, verduras y carnes. O cuando revisamos planillas de personas, vemos distintos tipos de profesiones. Si revisamos datos por pa√≠ses, finalmente √©stos son categor√≠as. Las categor√≠as est√°n por todos lados.\n\nPor otro lado, el conocimiento de factores es un plus muy potente para analizar datos y realizar la exploraci√≥n de los mismos. Tambi√©n, para inteligencia artificial, el manejo de datos categ√≥ricos es muy relevante. Muchas veces el transformar datos cont√≠nuos en factores ayuda a mejorar el desempe√±o de los modelos predictivos y es parte del [feature engineering](https://en.wikipedia.org/wiki/Feature_engineering), uno de los pasos b√°sicos previos antes del desarrollo de cualquier modelo de inteligencia artificial.\n\n## Carga de datos\n\nOk. Ya tenemos claro que, al analizar datos, debemos conocer m√©todos para trabajar con categor√≠as o factores.\n\nPara ello, R y su framework `tidyverse` nos ofrece `forcats`. Una librer√≠a especializada en el manejo de factores. Te recomiendo que revises la [documentaci√≥n oficial](https://forcats.tidyverse.org/) del la librer√≠a.\n\nAhora revisaremos muchas de sus funciones y que te ser√°n de gran utilidad en el d√≠a a d√≠a.\n\nPara los ejemplos usar√© [estos datos disponibles en Kaggle](https://www.kaggle.com/datasets/russellyates88/suicide-rates-overview-1985-to-2016).\n\nPrimero cargamos las librer√≠as que usaremos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(here)\nlibrary(janitor)\n```\n:::\n\n\nVeamos un poco los datos...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::i_am(\"index.qmd\")\nsuicides <- read_csv2(\"master.csv\") |> \n  clean_names()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(suicides)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 27,820\nColumns: 12\n$ country           <chr> \"Albania\", \"Albania\", \"Albania\", \"Albania\", \"Albania‚Ä¶\n$ year              <dbl> 1987, 1987, 1987, 1987, 1987, 1987, 1987, 1987, 1987‚Ä¶\n$ sex               <chr> \"male\", \"male\", \"female\", \"male\", \"male\", \"female\", ‚Ä¶\n$ age               <chr> \"15-24 years\", \"35-54 years\", \"15-24 years\", \"75+ ye‚Ä¶\n$ suicides_no       <dbl> 21, 16, 14, 1, 9, 1, 6, 4, 1, 0, 0, 0, 2, 17, 1, 14,‚Ä¶\n$ population        <dbl> 312900, 308000, 289700, 21800, 274300, 35600, 278800‚Ä¶\n$ suicides_100k_pop <chr> \"6.71\", \"5.19\", \"4.83\", \"4.59\", \"3.28\", \"2.81\", \"2.1‚Ä¶\n$ country_year      <chr> \"Albania1987\", \"Albania1987\", \"Albania1987\", \"Albani‚Ä¶\n$ hdi_for_year      <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, ‚Ä¶\n$ gdp_for_year      <chr> \"2,156,624,900\", \"2,156,624,900\", \"2,156,624,900\", \"‚Ä¶\n$ gdp_per_capita    <dbl> 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 79‚Ä¶\n$ generation        <chr> \"Generation X\", \"Silent\", \"Generation X\", \"G.I. Gene‚Ä¶\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(suicides)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 √ó 12\n  country  year sex    age       suici‚Ä¶¬π popul‚Ä¶¬≤ suici‚Ä¶¬≥ count‚Ä¶‚Å¥ hdi_f‚Ä¶‚Åµ gdp_f‚Ä¶‚Å∂\n  <chr>   <dbl> <chr>  <chr>       <dbl>   <dbl> <chr>   <chr>   <chr>   <chr>  \n1 Albania  1987 male   15-24 ye‚Ä¶      21  312900 6.71    Albani‚Ä¶ <NA>    2,156,‚Ä¶\n2 Albania  1987 male   35-54 ye‚Ä¶      16  308000 5.19    Albani‚Ä¶ <NA>    2,156,‚Ä¶\n3 Albania  1987 female 15-24 ye‚Ä¶      14  289700 4.83    Albani‚Ä¶ <NA>    2,156,‚Ä¶\n4 Albania  1987 male   75+ years       1   21800 4.59    Albani‚Ä¶ <NA>    2,156,‚Ä¶\n5 Albania  1987 male   25-34 ye‚Ä¶       9  274300 3.28    Albani‚Ä¶ <NA>    2,156,‚Ä¶\n6 Albania  1987 female 75+ years       1   35600 2.81    Albani‚Ä¶ <NA>    2,156,‚Ä¶\n# ‚Ä¶ with 2 more variables: gdp_per_capita <dbl>, generation <chr>, and\n#   abbreviated variable names ¬π‚Äãsuicides_no, ¬≤‚Äãpopulation, ¬≥‚Äãsuicides_100k_pop,\n#   ‚Å¥‚Äãcountry_year, ‚Åµ‚Äãhdi_for_year, ‚Å∂‚Äãgdp_for_year\n```\n:::\n:::\n\n\n## as_factor\n\nEn este art√≠culo no realizaremos an√°lisis estad√≠sticos pensando en modelos de inteligencia artificial, que es lo cl√°sico que se realiza en Kaggle. Sino que veremos el uso de la librer√≠a `forcats`.\n\nRevisemos la variable `age` del dataset.\n\nEsta variable est√° definida como *string*. Es decir, como una cadena de caracteres.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(suicides$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:27820] \"15-24 years\" \"35-54 years\" \"15-24 years\" \"75+ years\" ...\n```\n:::\n:::\n\n\nSi queremos realizar an√°lisis de este dataset, el tener esta variable como string no es buena idea. Parece m√°s razonable transformarlo a un factor. La librer√≠a `forcats` contiene la funci√≥n `as_factor()` que nos permite hacer eso.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides <- suicides |> \n  mutate(age = as_factor(age))\n```\n:::\n\n\nVeamos nuevamente la estructura de la variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(suicides$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Factor w/ 6 levels \"15-24 years\",..: 1 2 1 3 4 3 2 4 5 6 ...\n```\n:::\n:::\n\n\nOk. Ahora la variable ya no es de tipo string, sino que la hemos cambiado a tipo factor con 6 niveles. Es decir, tiene 6 categor√≠as. Ve√°moslas...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(suicides$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"15-24 years\" \"35-54 years\" \"75+ years\"   \"25-34 years\" \"55-74 years\"\n[6] \"5-14 years\" \n```\n:::\n:::\n\n\n## fct_relevel\n\nSi te fijas bien, el orden de las categor√≠as no est√° bien. Me refiero a que no sigue un orden ascendente o descendente, sino que est√° desordenado. Pues bien, podemos reordenarlos usando la funci√≥n `fct_relevel()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides <- suicides |>\n  mutate(age = fct_relevel(age,\n                           \"5-14 years\",\n                           \"15-24 years\",\n                           \"25-34 years\",\n                           \"35-54 years\",\n                           \"55-74 years\",\n                           \"75+ years\"\n  ))\n\nlevels(suicides$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"5-14 years\"  \"15-24 years\" \"25-34 years\" \"35-54 years\" \"55-74 years\"\n[6] \"75+ years\"  \n```\n:::\n:::\n\n\nPara efectos demostrativos, usar√© el argumento `after` de `fct_relevel()` para reordenar una categor√≠a.\n\nAc√° har√© que \"5-14 years\" quede despu√©s del √≠ndice 1 (recuerda que en R, el √≠ndice parte en 1).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides <- suicides |> \n  mutate(age = fct_relevel(age, \"5-14 years\", after = 1))\n\nlevels(suicides$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"15-24 years\" \"5-14 years\"  \"25-34 years\" \"35-54 years\" \"55-74 years\"\n[6] \"75+ years\"  \n```\n:::\n:::\n\n\nVolver√© a ordenarlo de forma correcta...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides <- suicides |> \n  mutate(age = fct_relevel(age, \"5-14 years\", after = 0))\n\nlevels(suicides$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"5-14 years\"  \"15-24 years\" \"25-34 years\" \"35-54 years\" \"55-74 years\"\n[6] \"75+ years\"  \n```\n:::\n:::\n\n\n## fct_reorder\n\nEsta funci√≥n es muy √∫til para los gr√°ficos, ya que permite reordenar los factores de modo de ajustarlos a nuestros requerimientos y necesidades de la visualizaci√≥n.\n\nRealicemos un gr√°fico para Chile:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides |>\n  filter(\n    year == 2015,\n    country == \"Chile\"\n  ) |>\n  group_by(age) |>\n  summarise(suicides_total = sum(suicides_no)) |>\n  mutate(prop = suicides_total / sum(suicides_total)) |>\n  ggplot(aes(age, suicides_total,\n    fill = suicides_total\n  )) +\n  geom_col(show.legend = FALSE) +\n  labs(\n    title = \"Suicides in Chile\", subtitle = \"Year 2015\", y = \"Total Number of Suicides\",\n    x = \"Age\", fill = \"Number of Suicides\"\n  ) +\n  coord_flip() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nEste gr√°fico est√° adecuado. Es informativo para saber cu√°l es el grupo etario que presenta m√°s suicidios. F√≠jate que el eje y est√° ordenado por las categor√≠as de `age`. Pero quiz√°s sea m√°s interesante ordenar los datos por el total de suicidios por grupo.\n\nVeamos c√≥mo hacerlo usando `fct_reorder`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides |>\n  filter(\n    year == 2015,\n    country == \"Chile\"\n  ) |>\n  group_by(age) |>\n  summarise(suicides_total = sum(suicides_no)) |>\n  mutate(prop = suicides_total / sum(suicides_total)) |>\n  ggplot(aes(fct_reorder(age, suicides_total), suicides_total,\n    fill = suicides_total\n  )) +\n  geom_col(show.legend = FALSE) +\n  labs(title = \"Suicides in Chile\", subtitle = \"Year 2015\", y = \"Total Number of Suicides\", x = \"Age\", fill = \"Number of Suicides\") +\n  coord_flip() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nEste orden deja m√°s claro la cantidad de suicidios por grupo etario y la proporci√≥n entre cada uno, a diferencia del gr√°fico anterior. F√≠jate en d√≥nde us√© `fct_reorder`. Podemos leerlo que deseamos que el eje x (primer par√°metro de `aes`) que corresponde a `age`, sea ordenado por `suicides_total`. Esto por defecto se ordena de mayor a menor (orden ascendente). Si deseamos hacerlo en orden descendente, debemos agregar el argumento `.desc = TRUE` al interior de `fct_reoder`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides |>\n  filter(\n    year == 2015,\n    country == \"Chile\"\n  ) |>\n  group_by(age) |>\n  summarise(suicides_total = sum(suicides_no)) |>\n  mutate(prop = suicides_total / sum(suicides_total)) |>\n  ggplot(aes(fct_reorder(age, suicides_total, .desc = TRUE), suicides_total,\n    fill = suicides_total\n  )) +\n  geom_col(show.legend = FALSE) +\n  labs(title = \"Suicides in Chile\", subtitle = \"Year 2015\", y = \"Total Number of Suicides\", x = \"Age\", fill = \"Number of Suicides\") +\n  coord_flip() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n## fct_explicit_na\n\nPara explicar esta funcion, vamos a usar la variable `hdi_for_year` (Human Development Index) que contiene datos NA.\n\nCreamos algunas categor√≠as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides <- suicides |>\n  mutate(\n    hdi_cat = case_when(\n      hdi_for_year >= 0.80 ~ \"Very High Development\",\n      hdi_for_year >= 0.70 ~ \"High Development\",\n      hdi_for_year >= 0.55 ~ \"Medium Development\",\n      hdi_for_year >= 0.35 ~ \"Low Development\",\n      hdi_for_year < 0.35 ~ \"Very Low Development\"\n    ),\n    hdi_cat = as_factor(hdi_cat)\n  )\n```\n:::\n\n\nYa sabemos que la variable `hdi_for_year` tiene datos NA, por lo que la nueva variable que acabamos de crear tambi√©n deber√≠a tener datos NA¬¥s.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(is.na(suicides$hdi_cat))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19456\n```\n:::\n:::\n\n\nPara trabajar con los datos, tenerlos como NA podr√≠a complicar los an√°lisis y algunas funciones aritm√©ticas no funcionar√≠an o ser√≠a m√°s dificil de interpretar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides |>\n  filter(country == \"Chile\") |>\n  group_by(country, hdi_cat) |>\n  summarise(n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 √ó 3\n# Groups:   country [1]\n  country hdi_cat                   n\n  <chr>   <fct>                 <int>\n1 Chile   Medium Development       24\n2 Chile   High Development         36\n3 Chile   Very High Development    60\n4 Chile   <NA>                    252\n```\n:::\n:::\n\n\nUna opci√≥n es usar `fct_explicit_na` para identificar los NA¬¥s y asignarle un valor a esa categor√≠a. Esto hace m√°s legible las tablas y los an√°lisis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides <- suicides |>\n  mutate(hdi_cat = fct_explicit_na(hdi_cat, na_level = \"Missing\"))\n\nsuicides |>\n  filter(country == \"Chile\") |>\n  group_by(country, hdi_cat) |>\n  summarise(n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 √ó 3\n# Groups:   country [1]\n  country hdi_cat                   n\n  <chr>   <fct>                 <int>\n1 Chile   Medium Development       24\n2 Chile   High Development         36\n3 Chile   Very High Development    60\n4 Chile   Missing                 252\n```\n:::\n:::\n\n\n## \n\nfct_lump\n\nPodemos agrupar categor√≠as, seg√∫n necesidad. Retomemos la variable que creamos `hdi_cat`.\n\nOmitimos los datos NA¬¥s, mantenemos las 2 categor√≠as con mayor cantidad de datos y el resto las agrupamos en una nueva categor√≠a \"Average/Low Development\" usando el argumento `other_level`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides |>\n  na.omit() |>\n  mutate(hdi_lumped = fct_lump(hdi_cat, n = 2, other_level = \"Average/Low Development\")) |>\n  count(hdi_lumped) |>\n  mutate(prop = n / sum(n)) |>\n  arrange(desc(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 √ó 3\n  hdi_lumped                  n  prop\n  <fct>                   <int> <dbl>\n1 Very High Development    3600 0.430\n2 High Development         2952 0.353\n3 Average/Low Development  1812 0.217\n```\n:::\n:::\n\n\nAcabamos de mantener las 2 categor√≠as con m√°s datos ( `n = 2`), pero tamb√©n podemos usar una proporci√≥n para hacer esa segmentaci√≥n. Para ello, usamos el argumento `prop.`\n\nVeamos un ejemplo...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides |>\n  na.omit() |>\n  mutate(hdi_relevel = fct_lump(hdi_cat, prop = 0.2, other_level = \"Below Average\")) |>\n  count(hdi_relevel) |>\n  mutate(prop = round(n / sum(n), 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 √ó 3\n  hdi_relevel               n  prop\n  <fct>                 <int> <dbl>\n1 Medium Development     1752 0.209\n2 High Development       2952 0.353\n3 Very High Development  3600 0.43 \n4 Below Average            60 0.007\n```\n:::\n:::\n\n\nUsamos `prop = 0.20` para indicar que cualquier categor√≠a con 20% o menos se indica como \"Below Average\".\n\n## **fct_infreq**\n\nEsta funci√≥n se usa junto a la librer√≠a `ggplot2`. Por ejemplo, para una gr√°fica de conteo de datos, esta funci√≥n permite ordenar por frecuencia.\n\nPrimero veamos sin usarla y luego us√°ndola.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides |> \n  na.omit() |> \n  add_count(hdi_cat) |> \n  ggplot(aes(hdi_cat)) +\n  geom_bar(stat = \"count\") +\n  labs(x = \"HDI Level\", y = \"Count\") +\n  theme_minimal() \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(suicides$hdi_cat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Medium Development\"    \"High Development\"      \"Very High Development\"\n[4] \"Low Development\"       \"Missing\"              \n```\n:::\n:::\n\n\nComo te dar√°s cuenta, el gr√°fico anterior est√° ordenado por los niveles de las categor√≠as de `hdi_cat` ( y que no est√° ordenado adem√°s). Podemos usar `fct_infreq` para order las categor√≠as por frecuencia (por defecto, lo hace en orden descendente).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides |> \n  na.omit() |> \n  add_count(hdi_cat) |> \n  ggplot(aes(fct_infreq(hdi_cat))) +\n  geom_bar(stat = \"count\") +\n  labs(x = \"HDI Level\", y = \"Count\") +\n  theme_minimal() \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n## fct_rev\n\nPodemos hacer lo mismo anterior, pero ordenarlos en forma ascendente. Para ellos usamos `fct_rev`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides |> \n  na.omit() |> \n  add_count(hdi_cat) |> \n  ggplot(aes(fct_rev(fct_infreq(hdi_cat)))) +\n  geom_bar(stat = \"count\") +\n  labs(x = \"HDI Level\", y = \"Count\") +\n  theme_minimal() \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n## fct_count\n\nEsta funci√≥n nos permite contar los datos por cada nivel de las categor√≠as.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfct_count(suicides$hdi_cat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 √ó 2\n  f                         n\n  <fct>                 <int>\n1 Medium Development     1752\n2 High Development       2952\n3 Very High Development  3600\n4 Low Development          60\n5 Missing               19456\n```\n:::\n:::\n\n\nEsta funci√≥n reemplaza lo que podemos hacer con la combinaci√≥n de `group_by` y `summarise`. Es lo mismo, pero con menos l√≠neas de c√≥digo. Esto podr√≠a ser √∫til en algunos casos para ser m√°s productivo, pero se pierde legibildad, pues hay que saber qu√© hace exactamente `fct_count`. En cambio, la combinaci√≥n de funciones es m√°s expl√≠cita. Queda a tu criterio de programador cual usar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides |> \n  group_by(hdi_cat) |> \n  summarise(n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 √ó 2\n  hdi_cat                   n\n  <fct>                 <int>\n1 Medium Development     1752\n2 High Development       2952\n3 Very High Development  3600\n4 Low Development          60\n5 Missing               19456\n```\n:::\n:::\n\n\n## fct_unique\n\nEsta funci√≥n es similar a unique de la base de R. O sea, muestra los valores √∫nicos de una variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfct_unique(suicides$hdi_cat) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Medium Development    High Development      Very High Development\n[4] Low Development       Missing              \n5 Levels: Medium Development High Development ... Missing\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(suicides$hdi_cat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Missing               Medium Development    High Development     \n[4] Very High Development Low Development      \n5 Levels: Medium Development High Development ... Missing\n```\n:::\n:::\n\n\n## fct_collapse\n\nEsta funci√≥n nos permite crear un factor a partir de otros. Es decir, colapsarlos en otro (o agruparlos).\n\nPara revisar esta funci√≥n, ahora usaremos la variable `generation`. Crearemos 2 nuevas variables que contienen distintas categor√≠as.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides |> \n  mutate(generation = as_factor(generation)) |> \n  mutate(generations = fct_collapse(generation,\n    \"Older Generations\" = c(\"Silent\", \"G.I. Generation\", \"Boomers\"),\n    \"Younger Generations\" = c(\"Generation X\", \"Generation Z\", \"Millenials\")\n  )) |> \n  pull(generations) |> \n  levels()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Younger Generations\" \"Older Generations\"  \n```\n:::\n:::\n\n\n## fct_other\n\nEsta funci√≥n permite agrupar niveles, para compararlo con uno en especial. Para definir la categor√≠a que queremos mentener usamos el argumento `keep` y el resto se agrupa en `other`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides |> \n  mutate(silent_against_other = fct_other(generation, keep = \"Silent\")) |> \n  pull(silent_against_other) |> \n  levels()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Silent\" \"Other\" \n```\n:::\n:::\n\n\n## fct_recode\n\nEsta funci√≥n permite recodificar un nivel. Es decir, asignarle un nuevo nombre a una categor√≠a. Esto tiene varias posibilidades, como hacer m√°s entendible una variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides |> \n  mutate(age_levels = fct_recode(age,\n                                 \"Child\" = \"5-14 years\",\n                                 \"Adolescent/Young Adult\"= \"15-24 years\",\n                                 \"Adult\" = \"25-34 years\",\n                                 \"Middle-Aged Adult\"= \"35-54 years\",\n                                 \"Older Adult\" = \"55-74 years\",\n                                 \"Senior\" = \"75+ years\")) |> \n  pull(age_levels) |> \n  levels()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Child\"                  \"Adolescent/Young Adult\" \"Adult\"                 \n[4] \"Middle-Aged Adult\"      \"Older Adult\"            \"Senior\"                \n```\n:::\n:::\n\n\n## fct_reorder2\n\nEsta funci√≥n se aplica para los gr√°ficos, junto a `ggplot2`. Lo que hace es reordenar los valores en base a un atributo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides |> \n  filter(country == \"Chile\") |> \n  group_by(year, age) |> \n  summarise(suicides_total = sum(suicides_no)) |> \n  ggplot(aes(year, suicides_total, colour = fct_reorder2(age, year, suicides_total))) +\n  geom_line(size = 2) + \n  labs(title = \"Suicides in Chile\",\n       y = \"Total Number of Suicides\",\n       x = \"Year\", colour = \"Age\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\nMira lo que pasa si no usamos `fct_reorder2`. Las l√≠neas de la gr√°fica son las mismas obviamente, pero la leyenda cambia y los colores de √©stas tambi√©n. La leyenda aparece en el orden de las categor√≠as que ordenamos antes, pero en el gr√°fco anterior, se ordenan en base al √∫ltimo valor y por tanto, la leyenda coincide con el orden de las lineas. Eso hace que sea m√°s legible y f√°cil de interpretar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides |> \n  filter(country == \"Chile\") |> \n  group_by(year, age) |> \n  summarise(suicides_total = sum(suicides_no)) |> \n  ggplot(aes(year, suicides_total, colour = age)) +\n  geom_line(size = 2) + \n  labs(title = \"Suicides in Chile\",\n       y = \"Total Number of Suicides\",\n       x = \"Year\", colour = \"Age\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\n## fct_relabel\n\nEsta funci√≥n permite modificar el nombre de los niveles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides$age |> \n  fct_relabel(~ str_replace_all(.x, \"years\", \" \")) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15-24   35-54   15-24   75+     25-34   75+    \nLevels: 5-14   15-24   25-34   35-54   55-74   75+  \n```\n:::\n:::\n\n\n## fct_anon\n\nEsta funci√≥n permite anonimizar una variable categ√≥rica.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides |> \n  mutate(generation = as_factor(generation) |> \n  fct_anon()) |> \n  group_by(generation) |> \n  count()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 √ó 2\n# Groups:   generation [6]\n  generation     n\n  <fct>      <int>\n1 1           5844\n2 2           4990\n3 3           6408\n4 4           2744\n5 5           6364\n6 6           1470\n```\n:::\n:::\n\n\nSe puede agregar un prefijo a cada categor√≠a anonimizada:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuicides |> \n  mutate(generation = as_factor(generation) |> \n  fct_anon(\"x-\")) |> \n  group_by(generation) |> \n  count()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 √ó 2\n# Groups:   generation [6]\n  generation     n\n  <fct>      <int>\n1 x-1         2744\n2 x-2         5844\n3 x-3         4990\n4 x-4         1470\n5 x-5         6364\n6 x-6         6408\n```\n:::\n:::\n\n\n## Finalmente...\n\nHemos revisado muchas de las funciones de la librer√≠a `forcats`, que como ves es bastante extensa. De hecho, no revisamos todas, hay varias m√°s, pero me parece que son muy espec√≠ficas y para casos muy puntuales. De todas formas, recuerda visitar la documentaci√≥n oficial para revisar m√°s detalles.\n\nComo puedes ver, el conocer alguna de estas funciones es de mucha utilidad para trabajar con datos categ√≥ricos. Y como siempre, recuerda practicar y practicar. No hay otra forma de que las cosas se te queden en la cabeza.\n\nNos vemos!!! üòÉ\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}