---
title: "Descargu칠 casi 3000 im치genes de Fornite!"
description: "Te ensa침ar칠 paso a paso como usar una API, usar funciones iterativas y automatizar diversas tareas para pasar de d칤as a solo minutos."
author: "Paulo Villarroel"
date: "2022-12-30"
categories: [tutorial, api, r]
image: "images.jpg"
execute:
  echo: true
  eval: false
---

Hola nuevamente!!!

Si es primera vez que est치s por ac치, espero que este contenido te sea interesante y logre desquearte alguna idea. Si ya me conoces, te agradezco estar por ac치 otra vez.

El post de hoy es medio off-topic de las tem치ticas que habitualmente hablo en el blog, pero me parece que es puede llegar a ser de inter칠s para muchas personas. Habitualmente mezclo cosas de distintas tem치ticas, algo como la medicina traslacional jajaja 游땐

Te cuento...

Mi hijo mayor es un entusiasta del dise침o gr치fico y a los videojuegos, como buen pre-adolescente. La cosa es la semana pasada me dijo que habia [encontrado una web](https://skindb.co/fortnite) en donde hay muchas skins y gr치ficas de Fortnite. Se supone que ah칤 estan todas las im치genes de los personajes, las armas, gliders y esas cosas del juego.

![](web-skins.jpg){fig-align="center" width="800"}

Como le gusta dise침ar con Photoshop, se descarga las im치genes que le gustan, las edita y haces alguno dise침os con ellas. El tema es que para descargarlas, hay que navegar por una serie de men칰s y hacer varios clics para tener la imagen en una buena resoluci칩n, para luego descargarla.

Lo que me pregunt칩 fue que si hab칤a una forma de descargar todas las im치genes del sitio de forma masiva, pero las de buena calidad, ya que hacerlo de a una era muy lento.

Ok... pues tenemos nuestro problema a resolver!!!

Ah!! De ahora en adelante, nombrar칠 a mi hijo como mi cliente.

## El problema

En programaci칩n partimos desde un problema que es necesario resolver. Bueno, hay un paso clave ac치 que es el de comprender profundamente el problema de modo de buscar las mejores alternativas de soluci칩n, que incluso, pueden no ser de programaci칩n como tal. Ahora, si este fuera un caso de Ciencia de Datos, igual hay un paso previo que es el de **an치lisis de factibilidad**, pero de eso no te voy a hablar ahora. Ya lo veremos en una pr칩xima oportunidad.

Pues bien, veamos el problema un poco m치s en detalle...

La idea es poder disponer de todas las im치genes de Fortnite en buena calidad para poder realizar dise침os. El tema, es que descargarlas manualmente desde la web es una tarea muy tediosa y lenta. Adem치s, que la cantidad de im치genes son bastantes.

## Posibles soluciones

Como me hab칤a mostrado la web, lo primero que se me pas칩 por la mente fue hacer un scraper para descargar las im치genes. Estuve indagando esta opci칩n, pero la desech칠 al poco tiempo. Los motivos fueron que algunas im치genes no er치n de buena calidad (la gran mayor칤a si lo era, en todo caso). Adem치s, las rutas en algunos casos eran extra침as y algunos botones para acceder a las secciones ten칤an bastante variabilidad. Todas esas cosas hac칤a que codificar el scraper sea m치s complejo. Posiblemente lo habr칤a resuelto con algunos d칤as de trabajo, pero ten칤a un requerimiento del cliente expl칤cito: necesitaba las im치genes antes de las 14hrs. 쯇or qu칠? No tengo idea jajaja

Pero bueno, fue as칤. Ten칤a un par de horas, entonces.

Como pens칠 que en el scraper me tomar칤a m치s tiempo del disponible, indagu칠 otras opciones.

Fortnite es un juego ultra conocido. Mi pensamiento era buscar otra web similar e intentar el scraper, pero mi cliente no deseaba otra web.

En la b칰squeda de webs me surgi칩 la duda... Bueno, y esta gente, 쮻e d칩nde saca las im치genes? Porque de alg칰n lado las sacan, no? No creo que se scrapeen mutuamente. Adem치s, que son cientos o miles de im치genes y que constantemente se est치n actualizando. Esa labor no se hace de forma manual.

Entonces, pens칠 que deb칤a haber un repositorio central con todas las im치genes y que los desarrolladores sacaban desde ah칤 sus datos. Lo cl치sico en estos casos es usar una API (Application Programming Interface, o Interfaz de Programaci칩n de Aplicaciones en espa침ol).

Te comento que estoy desarrollando una serie de art칤culos para ense침ar qu칠 son las API y c칩mo consumirlas. Puedes [leer este otro art칤culo](https://www.paulovillarroel.com/posts/api-cero-a-experto-p1/) en donde explico desde cero qu칠 son las API. A modo de ultra resumen, una API podemos entenderlas como la forma en que 2 sistemas inform치ticos se comunican para lo cual usan una serie de protocolos y estandarizaciones de modo que se puedan entender. Entonces, una parte hace una solicitud y la otra (el servidor) responde con algunos determinados datos. Si no sabes mucho del tema, igaual te aconsejo que te leas ese art칤culo primero y lueg vuleve a 칠ste, para que te quede todo m치s claro.

En este caso, me puse a buscar alguna API de Fortnite que estuviera disponible.

Hay una web que me gusta bastante y que suelo usar, pues tiene cientos de API y es bastante ordenada. Se llama [Rapid API](https://rapidapi.com/hub).

![](rapidapi.jpg){fig-align="center" width="800"}

Bueno, investigando la web de Rapid API encontr칠 varias de Fortnite. \
Me llam칩 la atenci칩n [una de ellas](https://rapidapi.com/brianiswu/api/fortnite1/), pues es bastante completa, tiene baja latencia, buena disponibilidad y es gratis.

Estuve viendo la API junto a mi cliente y le pareci칩 una buena idea.

Pues bien! Ahora vamos a programar un poco para implementar el consumo de la API.

## La soluci칩n

El lenguaje que usar칠 es R, pues es el que m치s controlo.

Para poder usar la API hay que suscribirse a ella. Esto te genera un token para que puedas interectuar y autentizarte en ella. Bueno, la API solo permite aplicar m칠todos GET. En todo caso, eso me da igual, pues es justamente lo que necesitamos. As칤 que todo bien.

![](rapidapi2.jpg){fig-align="center" width="800"}

La API tiene varios **endpoints**. Los endpoint de un API son puntos finales o direcciones en un servidor que pueden ser accedidos a trav칠s de la red (como Internet) para recibir o enviar datos. Un API puede tener m칰ltiples endpoint, y cada uno de ellos puede realizar una funci칩n espec칤fica, como obtener datos de una base de datos, enviar un correo electr칩nico, o realizar una acci칩n en un sistema externo.

En resumen, los endpoint de un API son puntos de acceso a los servicios y funcionalidades que ofrece una aplicaci칩n o sistema a trav칠s de la red. Para nuestro caso, la API nos ofrece varias opciones. Entre ellas hay una que nos pareci칩 interesante y es que nos permite acceder a un listado con todos los skins y elementos de los personajes. A primera vista parece ser lo que necesitamos. Pero es necesario darle una vista un poco m치s en detalle.

Entonces, veamos c칩mo pedir esos datos y ver qu칠 nos da...

Para implementar el m칠todo GET en R, podemos usar este c칩digo:

```{r}

library(httr)

url <- "https://fortnite1.p.rapidapi.com/items/list"

response <- VERB("GET", url, add_headers(
    "Authorization" = "string", 
    "X-RapidAPI-Key" = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", 
    "X-RapidAPI-Host" = "fortnite1.p.rapidapi.com"), 
    content_type("application/octet-stream"))

content(response, "text")

```

En Python, podemos hacerlo de la siguiente forma:

```{python}

import requests

url = "https://fortnite1.p.rapidapi.com/items/list"

headers = {
	"Authorization": "string",
	"X-RapidAPI-Key": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
	"X-RapidAPI-Host": "fortnite1.p.rapidapi.com"
}

response = requests.request("GET", url, headers=headers)

print(response.text)

```

He reemplazo la API-key por XXXXXXX l칩gicamente por temas de seguridad. Ese dato es 칰nico para cada persona que se suscriba a a API, asi que reempl치zalo por el que te corresponda.

La respuesta del servidor es un JSON.

El JSON (JavaScript Object Notation) es un formato de texto utilizado para representar datos estructurados. Es muy com칰n en el desarrollo de aplicaciones y se utiliza para intercambiar datos a trav칠s de la red (como Internet).

Un archivo o texto JSON se compone de pares de clave-valor, que se encierran entre llaves {}. Cada par de clave-valor se separa con una coma. Las claves son cadenas de texto (encerradas entre comillas) y los valores pueden ser de diferentes tipos, como n칰meros, cadenas de texto, o incluso otros objetos JSON anidados.

Aqu칤 hay un ejemplo de c칩mo se ver칤a un objeto JSON:

```{r}

{
  "nombre": "Juan",
  "edad": 30,
  "direcci칩n": {
    "calle": "Calle Falsa",
    "ciudad": "Ciudad Falsa",
    "pa칤s": "Pa칤s Falso"
  },
  "intereses": ["lectura", "deportes", "viajes"]
}

```

En este ejemplo, tenemos un objeto JSON con cuatro pares de clave-valor: "nombre", "edad", "direcci칩n" y "intereses". El valor de "nombre" es una cadena de texto, el valor de "edad" es un n칰mero, el valor de "direcci칩n" es otro objeto JSON anidado y el valor de "intereses" es una lista de cadenas de texto.

JSON es muy utilizado en el desarrollo de aplicaciones porque es un formato sencillo y f치cil de leer tanto para personas como para m치quinas. Adem치s, es ampliamente compatible con diferentes lenguajes de programaci칩n y plataformas.

Ok... ya con eso explicado a grandes rasgos, veamos que nos da nuestra API de Fortnite:

```{r}

> content(response, "text")

[1] "{\"lastUpdate\":0,\"lanuage\":\"en\",\"data\":[{\"itemId\":\"7fe1e64e-fc28-4a2c-bb1e-d5711a04fb16\",\"lastUpdate\":1668185110,\"item\":{\"name\":\"Gods of Thunder Pack\",\"description\":\"\",\"type\":\"bundle\",\"rarity\":\"epic\",\"series\":\"marvel\",\"cost\":2500,\"upcoming\":false,\"images\":{\"icon\":\"https://dropin-bucket.mativecdn.com/cosmetics/br/7fe1e64e-fc28-4a2c-bb1e-d5711a04fb16_l5bp7gje/icon.png\",\"featured\":null,\"background\":\"https://dropin-bucket.mativecdn.com/cosmetics/br/7fe1e64e-fc28-4a2c-bb1e-d5711a04fb16_l5bp7gje/icon.png\",\"information\":\"https://dropin-bucket.mativecdn.com/cosmetics/br/7fe1e64e-fc28-4a2c-bb1e-d5711a04fb16_l5bp7gje/icon.png\"},\"backpack\":{},\"obtained\":\"2500\",\"obtained_type\":\"vbucks\",\"ratings\":{\"avgStars\":3.68,\"totalPoints\":2228,\"numberVotes\":606},\"costmeticId\":\"7fe1e64e-fc28-4a2c-bb1e-d5711a04fb16_l5bp7gje\".....
```

Qu칠 es eso!!! 游땠

Recort칠 la respuesta, porque era muy larga. En todo caso, verlo as칤 es medio complejo y se ve horrible. Se ve que tiene varios datos, pero tratemos de darle una forma m치s simple de leer y ver si realmente nos sirve para resolver el problema de mi cliente.

Para el caso de R, podemos usar la librer칤a `jsonlite` que nos facilita leer este tipo de respuestas y transformarla a un objeto con el cual podamos interactuar de mejor forma:

```{r}

items <- fromJSON(rawToChar(response$content))

```

Con eso obtenemos una lista ordenada con todos los datos de la API.

```{r}

df <- unnest(items$data$item, cols = c(images, backpack, ratings))

```

Luego, pasamos esta lista a un dato de tipo dataframe, que nos permite estructurar los datos como una tabla y que facilita ver que hay dentro.

Nos da como resultado algo as칤. Ojo, el archivo tiene m치s de 8300 filas y 19 variables (columnas).

![](df.jpg){fig-align="center" width="800"}

Al ver que hay, vemos que contiene varios links a im치genes .*png*

Creo que nos gusta!! 游꿀

Estuvimos mirando, en detalle, los datos y los links. Encontramos que hay algunos variables que contienen links a las im치genes que est치bamos buscando. Si!!! Efectivamente. Ten칤amos un listado muy extenso con los detalles de los personajes de Fortnite con link a sus skins, armas y una serie de elementos.

Genial!!!

![](skin.png){fig-align="center" width="500"}

Muy bien. Ya ten칤amos varias cosas. Ese listado con los personajes y los links a sus im치genes, con buena calidad. Incluso, varias de las que en la web tenian poca resoluci칩n, ac치 estaban bien. Mejor a칰n.

Ahora toca seguir con la soluci칩n, porque hasta ahora solo tenemos un listado gigante de links. Que est치 bien, pero no tiene sentido copiar y pegar cada link en el navegador, para luego descargar las im치genes. Al final, es casi lo mismo de antes. Y son miles de registros. No nos sirve esa l칩gica. Debemos automatizar la lectura de esos links y las descargas.

Entonces, vamos con la segunda parte... Automatizar las descargas.

## Automatizando

Te voy a dejar el c칩digo que hicimos y luego te lo explico...

```{r}

library(tidyverse)

featured <- df |> 
  filter(featured != is.na(featured)) |> 
  mutate(name = str_replace_all(name, " ", "-")) |> 
  select(name, featured)

url <- "https://dropin-bucket.mativecdn.com/cosmetics/br/character_darkazalea/featured.png"

destfile <- "C:/your/path/fortnite/img/image.png"

download.file(url, destfile, mode = "wb")

```

Primero, hago alguna manipulaci칩n del listado de antes, pues no todos las variables nos sirven y ajustamos un poco los nombres de las variables.

Para probar si los pasos para descargar las i치genes est치n bien, hago un prueba con 1 link (y no con los miles de registros). En R tenemos la funci칩n `download.file()` que nos permite descargar archivos desde internet. A esta funci칩n le tenemos que pasar 2 par치metros: la url (donde est치 el archivo en la web) y la ruta de destino del archivo. Finalmente se agrega el `modo = "wb"` para que no hayan problemas de codificaci칩n del archivo de tipo imagen (en Windows eso suele pasar en estos casos).

Luego de la prueba, logramos descargar la imagen sin problemas.

Lo que toca ahora es aplicarlo a todas las im치genes y links. Para ello, construimos el siguiente `for`:

```{r}

for (i in (1:nrow(featured))){
  
  names <- featured$name[i]
  url <- featured$featured[i]
  destfile <- paste0("C:/your/path/fortnite/img/", names ,".png")
  
  download.file(url, destfile, mode = "wb")
  
}

```

Este c칩digo no es el mejor, tiene varias cosas que se podr칤an optimizar, pero recuerda que mi cliente me estableci칩 un l칤mite horario impostergable jajaja

Lo importante...

El c칩digo funcion칩!! Se tom칩 su tiempo, varios minutos. Despu칠s de todo, descargu칠 **m치s de 3000 im치genes.**

쯉e puede mejorar? Si, claro. Pero es posible que no vuelva a usar el c칩digo en mucho tiempo y ya ten칤a las im치genes. Asi que ponerme a optimizarlo, en esos momentos, no ten칤a mucho sentido.

Cuando le mostr칠 el resultado a mi cliente qued칩 sorprendido 游뱚

No pod칤a creer que ten칤a m치s de 3000 im치genes de alta calidad de sus personajes de Fortnite en una sola carpeta. Y antes del plazo que me hab칤a definido. Boom! Misi칩n cumplida.

Buen칤simo!!! 游꿀

Ok. Ahora que estoy escribiendo este art칤culo, se me ocurri칩 hacerle algunas mejoras al c칩digo:

```{r}

sapply(seq_len(nrow(featured)), function(i) {
  
  names <- featured$name[i]
  url <- featured$featured[i]
  destfile <- paste0("C:/your/path/fortnite/img/", names ,".png")
  
  download.file(url, destfile, mode = "wb")
  
})

```

Us칠 la funci칩n `seq_len()` en lugar de `1:nrow(featured)` para iterar sobre los 칤ndices de las filas de `featured`. Esto es m치s r치pido y evita tener que evaluar `nrow(featured)` en cada iteraci칩n del bucle.

Adem치s, us칠 la funci칩n `sapply()` en lugar de un bucle `for` para descargar los archivos. Esto es m치s r치pido y puede ser m치s f치cil de leer y mantener.

## Conclusiones

Muchas veces me contactan personas que est치n empezando a programar y me dicen que no tienen proyectos para hacer, que no saben de donde sacar datos o cosas as칤. A veces, no podemos acceder a los datos que nos gustar칤a en especial en salud que hay hartos temas de privacidad. Pero podemos usar otros tipos de datos que de todas formas nos permiten ejercitar nuestras habilidades y l칩gica. Tienes que ser curiso/a e indagar varias alternativas. No te quedes con lo primero que se te ocurra.

Adem치s, lo relevante es lograr identificar bien el problema, las limitaciones y los requisitos que nos permiten darnos cuenta de cu치ndo lo resolver칤amos. Es com칰n no detenerse en esos puntos y lanzarse de una al codigo.

Separa el problema en peque침as partes, m치s abordables y manejables.

Valida r치pido con el cliente los avances y si las salidas cumplen sus expectativas. Todos esas partes (en que dividiste el problema) val칤dalas y avanza en a medida que sea necesario.

La tecnolog칤a sirve para mucho, pero una de las cosas que ayuda mucho es para acceder a grandes vol칰menes datos y automatizar actividades, reduciendo las tareas manuales y los tiempos de ejecuci칩n.

Y, finalmente, si tu soluci칩n resuelve el problema, d칠jalo as칤. En especial si es un proyecto puntual. Ya habr치 momentos de optimizar el c칩digo y de mejorar su desempe침o y esas cosas, pero es un trabajo posterior y solo para casos en donde tengas que reutilzar el c칩digo o que haya que hacerle mantenimiento. Primero enf칩cate en resolver el problema. Da igual si queda feo. A tu cliente no le interesa el c칩digo, le interesa el resultado. La clave es resolver el problema!

Espero que este art칤culo te haya sido de utilidad.

Saludos!
