---
title: "Factores en R"
description: "Breve tutorial sobre las funciones m치s interesantes para trabajar con factores en R."
author: "Paulo Villarroel"
date: "2022-10-04"
categories: [r, tutorial]
image: "legos.jpg"
---

Hola!!

Hoy toca ver c칩digo. Yeahhh!!! 游때

En mi experiencia, uno de los aspectos m치s relvantes a la hora de trabajar con datos, es saber manejar los datos categ칩ricos o factores.

En la vida nos topamos a cada instante con este tipo de datos. Cuando vamos al supermercado, compramos frutas, l치cteos, verduras y carnes. O cuando revisamos planillas de personas, vemos distintos tipos de profesiones. Si revisamos datos por pa칤ses, finalmente 칠stos son categor칤as. Las categor칤as est치n por todos lados.

Por otro lado, el conocimiento de factores es un plus muy potente para analizar datos y realizar la exploraci칩n de los mismos. Tambi칠n, para inteligencia artificial, el manejo de datos categ칩ricos es muy relevante. Muchas veces el transformar datos cont칤nuos en factores ayuda a mejorar el desempe침o de los modelos predictivos y es parte del [feature engineering](https://en.wikipedia.org/wiki/Feature_engineering), uno de los pasos b치sicos previos antes del desarrollo de cualquier modelo de inteligencia artificial.

## Carga de datos

Ok. Ya tenemos claro que, al analizar datos, debemos conocer m칠todos para trabajar con categor칤as o factores.

Para ello, R y su framework `tidyverse` nos ofrece `forcats`. Una librer칤a especializada en el manejo de factores. Te recomiendo que revises la [documentaci칩n oficial](https://forcats.tidyverse.org/) del la librer칤a.

Ahora revisaremos muchas de sus funciones y que te ser치n de gran utilidad en el d칤a a d칤a.

Para los ejemplos usar칠 [estos datos disponibles en Kaggle](https://www.kaggle.com/datasets/russellyates88/suicide-rates-overview-1985-to-2016).

Primero cargamos las librer칤as que usaremos:

```{r}
#| warning: false

library(tidyverse)
library(here)
library(janitor)
```

Veamos un poco los datos...

```{r}
#| warning: false

here::i_am("index.qmd")
suicides <- read_csv2("master.csv") |> 
  clean_names()
```

```{r}
glimpse(suicides)
```

```{r}
head(suicides)
```

## as_factor

En este art칤culo no realizaremos an치lisis estad칤sticos pensando en modelos de inteligencia artificial, que es lo cl치sico que se realiza en Kaggle. Sino que veremos el uso de la librer칤a `forcats`.

Revisemos la variable `age` del dataset.

Esta variable est치 definida como *string*. Es decir, como una cadena de caracteres.

```{r}
str(suicides$age)
```

Si queremos realizar an치lisis de este dataset, el tener esta variable como string no es buena idea. Parece m치s razonable transformarlo a un factor. La librer칤a `forcats` contiene la funci칩n `as_factor()` que nos permite hacer eso.

```{r}
suicides <- suicides |> 
  mutate(age = as_factor(age))
```

Veamos nuevamente la estructura de la variable.

```{r}
str(suicides$age)
```

Ok. Ahora la variable ya no es de tipo string, sino que la hemos cambiado a tipo factor con 6 niveles. Es decir, tiene 6 categor칤as. Ve치moslas...

```{r}
levels(suicides$age)
```

## fct_relevel

Si te fijas bien, el orden de las categor칤as no est치 bien. Me refiero a que no sigue un orden ascendente o descendente, sino que est치 desordenado. Pues bien, podemos reordenarlos usando la funci칩n `fct_relevel()`.

```{r}
suicides <- suicides |>
  mutate(age = fct_relevel(age,
                           "5-14 years",
                           "15-24 years",
                           "25-34 years",
                           "35-54 years",
                           "55-74 years",
                           "75+ years"
  ))

levels(suicides$age)
```

Para efectos demostrativos, usar칠 el argumento `after` de `fct_relevel()` para reordenar una categor칤a.

Ac치 har칠 que "5-14 years" quede despu칠s del 칤ndice 1 (recuerda que en R, el 칤ndice parte en 1).

```{r}
suicides <- suicides |> 
  mutate(age = fct_relevel(age, "5-14 years", after = 1))

levels(suicides$age)
```

Volver칠 a ordenarlo de forma correcta...

```{r}
suicides <- suicides |> 
  mutate(age = fct_relevel(age, "5-14 years", after = 0))

levels(suicides$age)
```

## fct_reorder

Esta funci칩n es muy 칰til para los gr치ficos, ya que permite reordenar los factores de modo de ajustarlos a nuestros requerimientos y necesidades de la visualizaci칩n.

Realicemos un gr치fico para Chile:

```{r}
suicides |>
  filter(
    year == 2015,
    country == "Chile"
  ) |>
  group_by(age) |>
  summarise(suicides_total = sum(suicides_no)) |>
  mutate(prop = suicides_total / sum(suicides_total)) |>
  ggplot(aes(age, suicides_total,
    fill = suicides_total
  )) +
  geom_col(show.legend = FALSE) +
  labs(
    title = "Suicides in Chile", subtitle = "Year 2015", y = "Total Number of Suicides",
    x = "Age", fill = "Number of Suicides"
  ) +
  coord_flip() +
  theme_minimal()
```

Este gr치fico est치 adecuado. Es informativo para saber cu치l es el grupo etario que presenta m치s suicidios. F칤jate que el eje y est치 ordenado por las categor칤as de `age`. Pero quiz치s sea m치s interesante ordenar los datos por el total de suicidios por grupo.

Veamos c칩mo hacerlo usando `fct_reorder`.

```{r}
suicides |>
  filter(
    year == 2015,
    country == "Chile"
  ) |>
  group_by(age) |>
  summarise(suicides_total = sum(suicides_no)) |>
  mutate(prop = suicides_total / sum(suicides_total)) |>
  ggplot(aes(fct_reorder(age, suicides_total), suicides_total,
    fill = suicides_total
  )) +
  geom_col(show.legend = FALSE) +
  labs(title = "Suicides in Chile", subtitle = "Year 2015", y = "Total Number of Suicides", x = "Age", fill = "Number of Suicides") +
  coord_flip() +
  theme_minimal()
```

Este orden deja m치s claro la cantidad de suicidios por grupo etario y la proporci칩n entre cada uno, a diferencia del gr치fico anterior. F칤jate en d칩nde us칠 `fct_reorder`. Podemos leerlo que deseamos que el eje x (primer par치metro de `aes`) que corresponde a `age`, sea ordenado por `suicides_total`. Esto por defecto se ordena de mayor a menor (orden ascendente). Si deseamos hacerlo en orden descendente, debemos agregar el argumento `.desc = TRUE` al interior de `fct_reoder`.

```{r}
suicides |>
  filter(
    year == 2015,
    country == "Chile"
  ) |>
  group_by(age) |>
  summarise(suicides_total = sum(suicides_no)) |>
  mutate(prop = suicides_total / sum(suicides_total)) |>
  ggplot(aes(fct_reorder(age, suicides_total, .desc = TRUE), suicides_total,
    fill = suicides_total
  )) +
  geom_col(show.legend = FALSE) +
  labs(title = "Suicides in Chile", subtitle = "Year 2015", y = "Total Number of Suicides", x = "Age", fill = "Number of Suicides") +
  coord_flip() +
  theme_minimal()
```

## fct_explicit_na

Para explicar esta funcion, vamos a usar la variable `hdi_for_year` (Human Development Index) que contiene datos NA.

Creamos algunas categor칤as:

```{r}
suicides <- suicides |>
  mutate(
    hdi_cat = case_when(
      hdi_for_year >= 0.80 ~ "Very High Development",
      hdi_for_year >= 0.70 ~ "High Development",
      hdi_for_year >= 0.55 ~ "Medium Development",
      hdi_for_year >= 0.35 ~ "Low Development",
      hdi_for_year < 0.35 ~ "Very Low Development"
    ),
    hdi_cat = as_factor(hdi_cat)
  )
```

Ya sabemos que la variable `hdi_for_year` tiene datos NA, por lo que la nueva variable que acabamos de crear tambi칠n deber칤a tener datos NA췂s.

```{r}
sum(is.na(suicides$hdi_cat))
```

Para trabajar con los datos, tenerlos como NA podr칤a complicar los an치lisis y algunas funciones aritm칠ticas no funcionar칤an o ser칤a m치s dificil de interpretar.

```{r}
#| warning: false

suicides |>
  filter(country == "Chile") |>
  group_by(country, hdi_cat) |>
  summarise(n = n())
```

Una opci칩n es usar `fct_explicit_na` para identificar los NA췂s y asignarle un valor a esa categor칤a. Esto hace m치s legible las tablas y los an치lisis.

```{r}
#| warning: false

suicides <- suicides |>
  mutate(hdi_cat = fct_explicit_na(hdi_cat, na_level = "Missing"))

suicides |>
  filter(country == "Chile") |>
  group_by(country, hdi_cat) |>
  summarise(n = n())
```

## 

fct_lump

Podemos agrupar categor칤as, seg칰n necesidad. Retomemos la variable que creamos `hdi_cat`.

Omitimos los datos NA췂s, mantenemos las 2 categor칤as con mayor cantidad de datos y el resto las agrupamos en una nueva categor칤a "Average/Low Development" usando el argumento `other_level`.

```{r}
#| warning: false

suicides |>
  na.omit() |>
  mutate(hdi_lumped = fct_lump(hdi_cat, n = 2, other_level = "Average/Low Development")) |>
  count(hdi_lumped) |>
  mutate(prop = n / sum(n)) |>
  arrange(desc(n))
```

Acabamos de mantener las 2 categor칤as con m치s datos ( `n = 2`), pero tamb칠n podemos usar una proporci칩n para hacer esa segmentaci칩n. Para ello, usamos el argumento `prop.`

Veamos un ejemplo...

```{r}
suicides |>
  na.omit() |>
  mutate(hdi_relevel = fct_lump(hdi_cat, prop = 0.2, other_level = "Below Average")) |>
  count(hdi_relevel) |>
  mutate(prop = round(n / sum(n), 3))
```

Usamos `prop = 0.20` para indicar que cualquier categor칤a con 20% o menos se indica como "Below Average".

## **fct_infreq**

Esta funci칩n se usa junto a la librer칤a `ggplot2`. Por ejemplo, para una gr치fica de conteo de datos, esta funci칩n permite ordenar por frecuencia.

Primero veamos sin usarla y luego us치ndola.

```{r}
suicides |> 
  na.omit() |> 
  add_count(hdi_cat) |> 
  ggplot(aes(hdi_cat)) +
  geom_bar(stat = "count") +
  labs(x = "HDI Level", y = "Count") +
  theme_minimal() 
```

```{r}
levels(suicides$hdi_cat)
```

Como te dar치s cuenta, el gr치fico anterior est치 ordenado por los niveles de las categor칤as de `hdi_cat` ( y que no est치 ordenado adem치s). Podemos usar `fct_infreq` para order las categor칤as por frecuencia (por defecto, lo hace en orden descendente).

```{r}
suicides |> 
  na.omit() |> 
  add_count(hdi_cat) |> 
  ggplot(aes(fct_infreq(hdi_cat))) +
  geom_bar(stat = "count") +
  labs(x = "HDI Level", y = "Count") +
  theme_minimal() 
```

## fct_rev

Podemos hacer lo mismo anterior, pero ordenarlos en forma ascendente. Para ellos usamos `fct_rev`.

```{r}
suicides |> 
  na.omit() |> 
  add_count(hdi_cat) |> 
  ggplot(aes(fct_rev(fct_infreq(hdi_cat)))) +
  geom_bar(stat = "count") +
  labs(x = "HDI Level", y = "Count") +
  theme_minimal() 
```

## fct_count

Esta funci칩n nos permite contar los datos por cada nivel de las categor칤as.

```{r}
fct_count(suicides$hdi_cat)
```

Esta funci칩n reemplaza lo que podemos hacer con la combinaci칩n de `group_by` y `summarise`. Es lo mismo, pero con menos l칤neas de c칩digo. Esto podr칤a ser 칰til en algunos casos para ser m치s productivo, pero se pierde legibildad, pues hay que saber qu칠 hace exactamente `fct_count`. En cambio, la combinaci칩n de funciones es m치s expl칤cita. Queda a tu criterio de programador cual usar.

```{r}
suicides |> 
  group_by(hdi_cat) |> 
  summarise(n = n())
```

## fct_unique

Esta funci칩n es similar a unique de la base de R. O sea, muestra los valores 칰nicos de una variable.

```{r}
fct_unique(suicides$hdi_cat) 
```

```{r}
unique(suicides$hdi_cat)
```

## fct_collapse

Esta funci칩n nos permite crear un factor a partir de otros. Es decir, colapsarlos en otro (o agruparlos).

Para revisar esta funci칩n, ahora usaremos la variable `generation`. Crearemos 2 nuevas variables que contienen distintas categor칤as.

```{r}
suicides |> 
  mutate(generation = as_factor(generation)) |> 
  mutate(generations = fct_collapse(generation,
    "Older Generations" = c("Silent", "G.I. Generation", "Boomers"),
    "Younger Generations" = c("Generation X", "Generation Z", "Millenials")
  )) |> 
  pull(generations) |> 
  levels()
```

## fct_other

Esta funci칩n permite agrupar niveles, para compararlo con uno en especial. Para definir la categor칤a que queremos mentener usamos el argumento `keep` y el resto se agrupa en `other`.

```{r}
suicides |> 
  mutate(silent_against_other = fct_other(generation, keep = "Silent")) |> 
  pull(silent_against_other) |> 
  levels()
```

## fct_recode

Esta funci칩n permite recodificar un nivel. Es decir, asignarle un nuevo nombre a una categor칤a. Esto tiene varias posibilidades, como hacer m치s entendible una variable.

```{r}
suicides |> 
  mutate(age_levels = fct_recode(age,
                                 "Child" = "5-14 years",
                                 "Adolescent/Young Adult"= "15-24 years",
                                 "Adult" = "25-34 years",
                                 "Middle-Aged Adult"= "35-54 years",
                                 "Older Adult" = "55-74 years",
                                 "Senior" = "75+ years")) |> 
  pull(age_levels) |> 
  levels()
```

## fct_reorder2

Esta funci칩n se aplica para los gr치ficos, junto a `ggplot2`. Lo que hace es reordenar los valores en base a un atributo.

```{r}
#| warning: false

suicides |> 
  filter(country == "Chile") |> 
  group_by(year, age) |> 
  summarise(suicides_total = sum(suicides_no)) |> 
  ggplot(aes(year, suicides_total, colour = fct_reorder2(age, year, suicides_total))) +
  geom_line(size = 2) + 
  labs(title = "Suicides in Chile",
       y = "Total Number of Suicides",
       x = "Year", colour = "Age") +
  theme_minimal()
```

Mira lo que pasa si no usamos `fct_reorder2`. Las l칤neas de la gr치fica son las mismas obviamente, pero la leyenda cambia y los colores de 칠stas tambi칠n. La leyenda aparece en el orden de las categor칤as que ordenamos antes, pero en el gr치fco anterior, se ordenan en base al 칰ltimo valor y por tanto, la leyenda coincide con el orden de las lineas. Eso hace que sea m치s legible y f치cil de interpretar.

```{r}
#| warning: false

suicides |> 
  filter(country == "Chile") |> 
  group_by(year, age) |> 
  summarise(suicides_total = sum(suicides_no)) |> 
  ggplot(aes(year, suicides_total, colour = age)) +
  geom_line(size = 2) + 
  labs(title = "Suicides in Chile",
       y = "Total Number of Suicides",
       x = "Year", colour = "Age") +
  theme_minimal()
```

## fct_relabel

Esta funci칩n permite modificar el nombre de los niveles.

```{r}
suicides$age |> 
  fct_relabel(~ str_replace_all(.x, "years", " ")) |> 
  head()
```

## fct_anon

Esta funci칩n permite anonimizar una variable categ칩rica.

```{r}
suicides |> 
  mutate(generation = as_factor(generation) |> 
  fct_anon()) |> 
  group_by(generation) |> 
  count()
```

Se puede agregar un prefijo a cada categor칤a anonimizada:

```{r}
suicides |> 
  mutate(generation = as_factor(generation) |> 
  fct_anon("x-")) |> 
  group_by(generation) |> 
  count()
```

## Finalmente...

Hemos revisado muchas de las funciones de la librer칤a `forcats`, que como ves es bastante extensa. De hecho, no revisamos todas, hay varias m치s, pero me parece que son muy espec칤ficas y para casos muy puntuales. De todas formas, recuerda visitar la documentaci칩n oficial para revisar m치s detalles.

Como puedes ver, el conocer alguna de estas funciones es de mucha utilidad para trabajar con datos categ칩ricos. Y como siempre, recuerda practicar y practicar. No hay otra forma de que las cosas se te queden en la cabeza.

Nos vemos!!! 游땎
