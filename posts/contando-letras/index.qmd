---
title: "Contando letras"
description: "Resolvemos un reto de l√≥gica de programaci√≥n, aprovechamos de hacerlos de varias formas y nos lanzamos con unos test unitarios adem√°s!"
author: "Paulo Villarroel"
date: "2022-11-23"
categories: [r, python, tutorial, katas]
image: "letters.jpg"
---

Hola!!

Que bueno que est√©s por estos lados nuevamente! Porque ya has le√≠do mis otros art√≠culos, verdad??

Verdad!!??

Ojito...

jajajaja ü§£

Ya, ok... En serio. Lo que vamos a ver en este art√≠culo es algo interesante. O es lo que pienso. Lo que har√© es resolver un reto de l√≥gica de programaci√≥n (o *kata* le dicen algunos). Pero quiero darle una peque√±a vuelta de tuerca al tema. No quiero que solo sea poner el c√≥digo y punto. Sino que explicar√© varias formas de resolverlo, algunas m√°s verbosas (es decir, con m√°s l√≠neas de c√≥digo) para que sea m√°s simple de seguir la l√≥gica y el paso a paso. La idea es evitar la "magia" o c√≥digos que hacen todo por debajo y uno ni se entera. Los explicar√© de forma progresiva. Tambi√©n usar√© otras formas de resolverlo con menos c√≥digo. Mi intenci√≥n es que veas que, generalmente, hay varias formas de resolver las cosas en programaci√≥n. No hay mejores o peores perse, pero hay algunos que son m√°s eficientes que otros o que son mas legibles y comprensibles.

Para resolverlo usar√©, principalmente, el lenguaje de progamaci√≥n R y tambi√©n pondr√© algo en Python por ah√≠. Me interesa que entiendas la l√≥gica de la soluci√≥n, el lenguaje que uses es lo de menos.

Por esos mismos motivos (para la l√≥gica), es que evitar√© usar librer√≠as o dependencias externas a las del propio lenguaje y que tienden a estar presentes en muchos lenguajes, quiz√°s con una sintaxis (la forma en c√≥mo se escribe) algo distinta, pero que hacen lo mismo. Y como te mencion√©, no busco generar el c√≥digo m√°s corto, eficiente o lindo, sino que sea f√°cil de entender.

Estamos?

# El problema

El problema no es nuevo ni una creaci√≥n m√≠a, sino que es de una web cl√°sica en donde puedes encontrar muchos desaf√≠os o retos de c√≥digo, llamada [CodeWars](https://www.codewars.com/).

El desaf√≠o que veremos ahora dice as√≠:

[![](kata-vowels.jpg){fig-align="center" width="800"}](https://www.codewars.com/kata/54ff3102c1bad923760001f3/r)

B√°sicamente, la idea es crear una funci√≥n que permita contar las vocales que tiene un determinado texto.

Se entiende?

Es simple. A priori, al menos.

# Soluciones

Ya. Tenemos nuestro desaf√≠o, ahora veamos c√≥mo podemos resolverlo.

Mi primer approach ser√° con R. Crear√© una funci√≥n que cuente las vocales de un texto que le pasemos a esa funci√≥n. Recuerda que para crear o definir una funci√≥n se usa `function`. A ella le agregamos un par√°metro `text`, que ser√° el texto que queremos analizar y contar las vocales.

Antes de partir, vamos a definir unos test unitarios. Los test unitarios son pruebas que consisten en aislar una parte del c√≥digo y comprobar que funciona a lo esperado. Son peque√±os tests que validan el comportamiento de un objeto y la l√≥gica, fundamentalmente. En R, para realizar este tipo de test usaremos la librer√≠a `testthat`. Se escapa de los alcances de este art√≠culo, pero te recomiendo que aprendas a realizar *testing*, pues es una forma de asegurarte que las cosas salen como deber√≠an salir, lo cual es especialmente √∫til cuando tienes desarrollos un poco m√°s extensos, hay varias personas metiendo mano o haces cambios en el c√≥digo y no quieres roper nada (roper es un t√©rmino usado en programaci√≥n para aludir a que ya no funciona bien algo). Si corremos el c√≥digo que te dejo abajo ver√°s que arroja puros errores!!!!! No!!!!!!!

Bueno, qu√© esperas? Si no hemos definido ninguna funci√≥n ni nada jajajaj ü§™

```{r}
library(testthat) # librer√≠a para test unitarios en R
```

```{yaml}
test_count_vowels <- test_that("Example Tests", {
  expect_equal(count_vowels("Esta es otra frase"), "Number of vowels: 7")
  expect_equal(count_vowels("Ma√±ana salimos al parque"), "Number of vowels: 10")
  expect_equal(count_vowels(""), "Number of vowels: 0")
})

# ‚îÄ‚îÄ Error (Line 2): Example Tests ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Error in `count_vowels("Esta es otra frase")`: could not find function "count_vowels"
# Backtrace:
#  1. testthat::expect_equal(count_vowels("Esta es otra frase"), "Number of vowels: 7")
#  2. testthat::quasi_label(enquo(object), label, arg = "object")
#  3. rlang::eval_bare(expr, quo_get_env(quo))
```

Ok. Ya tenemos nuetro test que falla por todos lados. Ahora debemos arreglarlo.

Partiremos definiendo nuestra funci√≥n `count_vowels`, que como te mencion√© antes, le pasaremos como argumento un texto en el par√°metro `text`.

A ver... mi l√≥gica de pensamiento es la siguiente... como necesito contar las vocales que tiene un texto, primero le tengo que decir al computador cu√°les son las letras que deseo contar (las vocales). Una vez que tenga eso claro, voy a buscar esas vocales en el texto, contar cu√°ntas hay y sumarlas.

Tener en mente la l√≥gica es lo b√°sico. Antes de ponder a escribir c√≥digo. Primero dise√±a la soluci√≥n (o algo parecido) en tu mente. Muchas veces yo uso un l√°piz y papel para tirar dibujos que me permitan entender los pasos y partes.

Vamos con el c√≥digo. Dentro de la funci√≥n especificamos:

-   Creamos el objeto `vowels` que es un vector de *strings* con las vocales.

-   Para poder buscar las vocales en el texto, necesito separar el texto en todas sus letras, porque mi b√∫squeda y conteo es por letra, no por un conjunto de ellas.

-   Creamos el objeto `split_text` que ser√° un vector con todas las letras del texto ya separadas. Para evitar complicaciones, pondremos todo a min√∫sculas. Recuerda que C no es igual a c, por ejemplo. Este tema no lo hab√≠a considerado al inicio, pero me di cuenta que no sumaba bien con algunas palabras y era por el asunto de las may√∫sculas.

-   Como deseo contar las vocales dentro del texto (ya separado por letras), usar√© un *for* para ello. Dejar√© un objeto `char_count = 0` en donde ir√© acumulando las sumas de vocales.

-   Implemento el *for*. F√≠jate que en la medida que recorro el vector del texto separado y encuentro una vocal, sumo 1 y lo voy acumulando. Para realizar esab b√∫squeda, us√© `char %in% vowels`.

-   Te recomiendo que veas la documentaci√≥n del operador `%in%` para m√°s detalles, pero lo que hace es lo que te mencion√©, recorre un vector por cada uno de sus elementos.

-   Finalmente, imprimo por consola ese n√∫mero acumulado de letras. Le puse un mensaje para que sea m√°s entendible la salida del c√≥digo.

As√≠ quedar√≠a esa implementaci√≥n:

```{r}
count_vowels <- function(text) {
  vowels <- c("a", "e", "i", "o", "u")
  split_text <- tolower(unlist(strsplit(text, "")))
  char_count <- 0

  for (char in split_text) {
    if (char %in% vowels) {
      char_count <- char_count + 1
    }
  }
  print(paste0("Number of vowels: ", char_count))
}
```

Podemos probarla con algunos ejemplos:

```{r}
count_vowels("hllp")
count_vowels("paulo")
count_vowels("Ma√±ana salimos al parque")
```

Ok... al parecer funciona... Veamos c√≥mo le va a nuestra funci√≥n con el test unitario:

```{r}
test_count_vowels <- test_that("Example Tests", {
  expect_equal(count_vowels("Esta es otra frase"), "Number of vowels: 7")
  expect_equal(count_vowels("Ma√±ana salimos al parque"), "Number of vowels: 10")
  expect_equal(count_vowels(""), "Number of vowels: 0")
})
```

Genial!!!!

Pasamos!!!! üéâ

Veamos una implementaci√≥n similar, pero esta vez en Python:

```{python}
def getCount(text):
    text = text.lower()
    vowels = ['a','e','i','o','u']
    numVowels = 0
    
    for char in text:
        if (char in vowels):
            numVowels += 1
    
    print(f"Number of vowels: {numVowels}")
```

Revisemos unos ejemplos:

```{python}
getCount("paulo")
getCount("Ma√±ana salimos al parque")
```

Ok... tenemos nuestras primeras formas de resolver este desaf√≠o de c√≥digo.

Hagamos una peque√±a variaci√≥n al desaf√≠o. Anteriomente est√°bamos contando todas las vocales que ten√≠a un texto. ¬øPero qu√© pasa si ahora lo que queremos saber es cu√°l es la vocal que m√°s repite?

Hagamos nuestros test primero, que como ya sabes, van a fallar porque no tenemos nada a√∫n.

```{yaml}
test_count_vowels <- test_that("Example Tests", {
  expect_equal(max_vowels("Esto es un texto"), "Vowel: e / Freq: 3")
  expect_equal(max_vowels("Hoy hizo calor"), "Vowel: o / Freq: 3")
  expect_equal(max_vowels(""), "No vowels in text")
})

# ‚îÄ‚îÄ Error (Line 2): Example Tests ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Error in `max_vowels("Esto es un texto")`: could not find function "max_vowels"
# Backtrace:
#  1. testthat::expect_equal(max_vowels("Esto es un texto"), "Vowel: e / Freq: 3")
#  2. testthat::quasi_label(enquo(object), label, arg = "object")
#  3. rlang::eval_bare(expr, quo_get_env(quo))
```

Vamos a usar parte de lo que tenemos realizado ya, y su l√≥gica por cierto. Finalmente, igual necesitamos identificar las vocales que hay en el texto, pero en esta ocasi√≥n, en vez de sumarlas, lo que haremos es contar cada vocal cu√°ntas apariciones tiene y seleccionaremos la que tiene mayor frecuencia.

La diferencia m√°s relevante con el reto anterior es que ahora debemos contar individualmente cada vocal. Antes solo acumul√°bamos la suma de las aparaciones. Para eso, me parece que m√°s l√≥gico armar una tabla con las vocales que tiene el texto y la frecuencia de cada una.

```{r}
text <- "Esta es una prueba del texto"

vowels <- c("a", "e", "i", "o", "u")
split_text <- tolower(unlist(strsplit(text, "")))
table_freq <- data.frame(table(split_text[split_text %in% vowels]))
```

El objeto `table_freq` contiene la tabla que te mencionaba. F√≠jate que lo que hice fue transformar una tabla media rara a un dataframe, que es m√°s √∫til para trabajar y calcular el m√°ximo de frecuencias.

```{r}
table(split_text[split_text %in% vowels])
```

```{r}
data.frame(table(split_text[split_text %in% vowels]))
```

Con esa tabla ya hecha, lo que debemos hacer es buscar la frecuencia m√°s alta (`max`) e indicar la vocal que corresponde a ese valor. Para eso, analiza esta l√≠nea de c√≥digo `table_freq$Var1[table_freq$Freq == max]`

```{r}
max_vowels <- function(text) {
  vowels <- c("a", "e", "i", "o", "u")
  split_text <- tolower(unlist(strsplit(text, "")))
  table_freq <- data.frame(table(split_text[split_text %in% vowels]))
  max <- max(table_freq$Freq)
  max_vowels_text <- table_freq$Var1[table_freq$Freq == max]

  print(paste0("Vowel: ", max_vowels_text, " / Freq: ", max))
}
```

```{r}
max_vowels("La salud necesita mejores personas")
```

Volvamos a probar nuestros test...

```{yaml}
test_count_vowels <- test_that("Example Tests", {
  expect_equal(max_vowels("Esto es un texto"), "Vowel: e / Freq: 3")
  expect_equal(max_vowels("Hoy hizo calor"), "Vowel: o / Freq: 3")
  expect_equal(max_vowels(""), "No vowels in text")
})

# [1] "Vowel: e / Freq: 3"
# [1] "Vowel: o / Freq: 3"
# [1] "Vowel:  / Freq: -Inf"
# ‚îÄ‚îÄ Failure (Line 2): Example Tests ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# max_vowels("Esto es un texto") not equal to "Vowel: 3 / Freq: 3".
# 1/1 mismatches
# x[1]: "Vowel: e / Freq: 3"
# y[1]: "Vowel: 3 / Freq: 3"
# 
# ‚îÄ‚îÄ Warning (Line 4): Example Tests ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# no non-missing arguments to max; returning -Inf
# Backtrace:
#  1. testthat::expect_equal(max_vowels(""), "No vowels in text")
#  4. global max_vowels("")
# 
# ‚îÄ‚îÄ Failure (Line 4): Example Tests ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# max_vowels("") not equal to "No vowels in text".
# 1/1 mismatches
# x[1]: "Vowel:  / Freq: -Inf"
# y[1]: "No vowels in text"
```

Mmmmmmm. A ver. Los 2 primeros test pasaron, pero el tercero fall√≥, el que tiene un argumento vac√≠o.

En el ejemplo anterior, cuando le pasamos un argumento vacio no arroj√≥ error, pero ac√° si. Posiblemente el tema pasa por la tabla.

```{r}
text <- ""

vowels <- c("a", "e", "i", "o", "u")
split_text <- tolower(unlist(strsplit(text, "")))
table_freq <- data.frame(table(split_text[split_text %in% vowels]))

table_freq
```

Si le pasamos un texto vac√≠o, no se genera la tabla, nos da como resultado `0 rows`. Bueno, es l√≥gico. Si no hay nada, la tabla no existe b√°sicamente. Para resolver este problema, podr√≠amos agregar un condicional a la funci√≥n. Lo que deber√≠a pasar es que cuando se detecte que el texto es vac√≠o, nos de un mensaje de error o algo similar, y si no es as√≠, que haga el tema de la tabla y todo lo dem√°s.

```{r}
max_vowels <- function(text) {
  vowels <- c("a", "e", "i", "o", "u")
  split_text <- tolower(unlist(strsplit(text, "")))

  if (text == "") {
    
    print("No vowels in text")
    
  } else {
    
    table_freq <- data.frame(table(split_text[split_text %in% vowels]))
    max <- max(table_freq$Freq)
    max_vowels_text <- table_freq$Var1[table_freq$Freq == max]

    print(paste0("Vowel: ", max_vowels_text, " / Freq: ", max))
    
  }
}
```

Corramos nuevamente nuestros lindos test unitarios:

```{r}
test_count_vowels <- test_that("Example Tests", {
  expect_equal(max_vowels("Esto es un texto"), "Vowel: e / Freq: 3")
  expect_equal(max_vowels("Hoy hizo calor"), "Vowel: o / Freq: 3")
  expect_equal(max_vowels(""), "No vowels in text")
})
```

Yuju!!!! üòç

Te dejo tarea para la casa. Mira el resultado siguiente:

```{r}
max_vowels("eeeoooaqui")
```

Epa! Ac√° las vocales e y o tienen ambas una frecuencia de 3 y son las m√°s altas. Nuestro c√≥digo no resuelve bien eso. Muestra correctamente las vocales, pero el mensaje es extra√±o. Se podr√≠a hacer mejor.

Es tu turno!! Int√©ntalo.

Ahora te voy a mostrar unas cuantas soluciones, pero con menos c√≥digo. Es m√°s complejo de entender si no sabes bien lo que hace cada funci√≥n, pero me parece interesante mostrarte otras opciones de resolver el problema original (el de contar vocales).

**Opci√≥n 1:**

```{r}
get_count_vowels <- function(text){
  vowels <- nchar(gsub("[^aeiou]", "", text, ignore.case = TRUE))
  print(paste0("Number of vowels: ", vowels))
}
```

```{r}
get_count_vowels("Esta es otra frase")
```

**Opci√≥n 2:**

```{r}
library(stringr) # Usando esta librer√≠a

count_vowels_lib <- function(text){
  str_count(text, "[AEIOUaeiou]")
  }
```

```{r}
count_vowels_lib("Esta es una prueba de texto")
```

**Opci√≥n 3:**

```{python}
getCount = lambda s: sum(s.count(i) for i in 'aeiou') # Opci√≥n un poco cr√≠ptica
```

```{python}
getCount("Frase linda")
```

# Finalmente

Uf! Teminamos este art√≠culo. Espero que te haya gustado y, principalmente, haya sido de utilidad.

Espero haber sido claro en la l√≥gica de pensamiento y la forma de resolver un problema. Adem√°s, de mostrarte muchas formas de abordarlo en distintos idiomas. Y algo que quiz√°s pas√≥ medio desapercibido, pero es muy relevante, son los [test unitarios](https://testthat.r-lib.org/) y la arquitectura de desarrollo TDD (T*est Driven Development)*. Esto ayuda mucho a tener un c√≥digo sostenible y si le haces cambios y falla, te vas a dar cuenta.

Recuerda dejar tus comentarios e inscribirte en el blog (en la secci√≥n de m√°s abajo).

Nos vemos!! ü§ó
